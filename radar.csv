name, ring, quadrant, isNew, description
Redpanda, Assess, Platforms, TRUE, <p><strong><a href="https://github.com/vectorizedio/redpanda">Redpanda</a></strong> is a streaming platform that provides a <a href="/radar/tools/apache-kafka">Kafka</a>-compatible API, allowing it to benefit from the Kafka ecosystem without having to deal with the complexities of a Kafka installation. For example, Redpanda simplifies operations by shipping as a single binary and avoiding the need for an external dependency such as ZooKeeper. Instead, it implements the Raft protocol and performs comprehensive tests to validate it's been <a href="https://vectorized.io/blog/validating-consistency/">implemented correctly</a>. One of Redpanda’s capabilities (available for enterprise customers only) is inline <a href="/radar/languages-and-frameworks/webassembly">WebAssembly (WASM)</a> transformations, using an embedded WASM engine. This allows developers to create event transformers in their language of choice and compile it to WASM. Redpanda also offers much reduced tail latencies and increased throughput due to a <a href="https://vectorized.io/blog/tpc-buffers/">series of optimizations</a>. Redpanda is an exciting alternative to Kafka and is worth assessing.</p>		
GitHub Actions, Assess, Tools, TRUE, <p>CI servers and build tools are some of the oldest and most widely used in our kit. They run the gamut from simple cloud-hosted services to complex, code-defined pipeline servers that support fleets of build machines. Given our experience and the wide range of options already available, we were initially skeptical when <strong><a href="https://docs.github.com/en/actions">GitHub Actions</a></strong> were introduced as another mechanism to manage the build and integration workflow. But the opportunity for developers to start small and easily customize behavior means that GitHub Actions are moving toward the default category for smaller projects. It's hard to argue with the convenience of having the build tool integrated directly into the source code repository. An enthusiastic community has emerged around this feature and that means a wide range of user-contributed tools and workflows are available to get started. Tools vendors are also getting on board via the <a href="https://github.com/marketplace?type=actions">GitHub Marketplace</a>. However, we still recommend you proceed with caution. Although code and <a href="/radar/tools/git">Git</a> history can be exported into alternative hosts, a development workflow based on GitHub Actions can't. Also, use your best judgment to determine when a project is large or complex enough to warrant an independently supported pipeline tool. But for getting up and running quickly on smaller projects, it's worth considering GitHub Actions and the ecosystem that is growing around them.</p>																					
Diagrams as code, Trial, Techniques, FALSE, <p>We’re seeing more and more tools that enable you to create software architecture and other diagrams as code. There are benefits to using these tools over the heavier alternatives, including easy version control and the ability to generate the DSLs from many sources. Tools in this space that we like include Diagrams, Structurizr DSL, AsciiDoctor Diagram and stables such as WebSequenceDiagrams, PlantUML and the venerable Graphviz. It’s also fairly simple to generate your own SVG these days, so don’t rule out quickly writing your own tool either. One of our authors wrote a small Ruby script to quickly create SVGs, for example.</p>
GitOps, Hold, Techniques, TRUE, <p>We suggest approaching <strong>GitOps</strong> with a degree of care, especially with regard to branching strategies. GitOps can be seen as a way of implementing <a href="/radar/techniques/infrastructure-as-code">infrastructure as code</a> that involves continuously synchronizing and applying infrastructure code from <a href="/radar/tools/git">Git</a> into various environments. When used with a "branch per environment" infrastructure, changes are promoted from one environment to the next by merging code. While treating code as the single source of truth is clearly a sound approach, we're seeing branch per environment lead to environmental drift and eventually environment-specific configs as code merges become problematic or even stop entirely. This is very similar to what we've seen in the past with <a href="/radar/techniques/long-lived-branches-with-gitflow">long-lived branches with GitFlow</a>.</p>																					
TypeScript, Adopt, language-and-frameworks, TRUE, <p><strong><a href="https://www.typescriptlang.org/">TypeScript</a></strong>, a statically typed language and superset of JavaScript, has become our sensible default. Large-scale projects benefit most from the type safety. Our developers favor its minimal configuration management, well-integrated IDE support and its ability to refactor code safely and gradually adopt types. With its <a href="https://definitelytyped.org/">good repository</a> of TypeScript-type definitions at hand, we benefit from all the rich JavaScript libraries while gaining type safety.</p>																			
